#' Encode and decode profile HMMs in raw bytes
#'
#' These functions are used to compress and decompress profile
#'   hidden Markov models for DNA to improve memory efficiency.
#'
#' @param x an object of class "PHMM"
#' @param z a raw vector in the encodePHMM schema
#' @return encodePHMM returns a raw vector. \code{decodePHMM} returns
#'   an object of class "PHMM".
#' @details TBA
#' @author Shaun Wilkinson
#' @examples #TBA
#' @name encoding
################################################################################
encodePHMM <- function(x){
  if(mode(x) == "raw") return(x)
  encode1 <- function(xx){ ## a number between 0.000001 and 100
    ## encodes as two bytes to (almost) 4 signif figs
    ## first 13 for the digits (2^13 = 8192) last 3 bits for exponent
    #(1e-6 -> 0, 1e+1 -> 7)
    if(!is.finite(xx)) return(as.raw(c(0, 0)))
    stopifnot(xx >= 1e-06 & xx < 100)
    expo <- floor(log10(xx))
    digi <- round((xx/10^(expo - 3) - 1000) * 0.9102122, 0)
    ## scale factor 8191/8999 = 0.9102122, 3 to get from 1 to 1000
    return(packBits(c(intToBits(digi)[1:13], intToBits(expo + 6)[1:3])))
  }
  logibits <- raw(32)
  if(any(is.finite(x$A[3, ]))) logibits[32] <- as.raw(1) # DI trans enabled?
  if(any(is.finite(x$A[7, ]))) logibits[31] <- as.raw(1) # ID trans enabled?
  logibytes <- packBits(logibits)
  sizebytes <- packBits(intToBits(x$size)) # 4 bytes for model size = 4bil max size
  A <- x$A[-(c(2, 3, 6, 7, 9)), ]
  A <- A[is.finite(A)] * -1 # now a vector
  A[A < 1e-06] <- 1e-06 ## minimum value (max prob remember to fix final DM trans to 1)
  Abytes <- as.vector(sapply(A, encode1))
  E <- x$E[1:3, ] * -1 # drop T row as can be calculated
  E[E < 1e-06] <- 1e-06
  Ebytes <- as.vector(sapply(E, encode1))
  qa <- x$qa[-c(3, 7)] * -1 # can't drop any
  qabytes <- as.vector(sapply(qa, encode1))
  qe <- x$qe * -1
  qebytes <- as.vector(sapply(qe, encode1))
  z <- c(logibytes, sizebytes, Abytes, Ebytes, qabytes, qebytes)
  return(z)
}
################################################################################
#' @rdname encoding
################################################################################
decodePHMM <- function(z){
  if(mode(z) != "raw") return(z)
  decode1 <- function(zz){ ## zz is a 2-byte raw vec
    res <- rawToBits(zz)
    expo <- as.integer(packBits(c(res[14:16], raw(5)))) - 6
    digi <- as.integer(packBits(c(res[1:13], raw(3)))) # 2 ints between 0 and 8191
    digi <- sum(digi* c(1, 256))
    digi <- round(digi/0.9102122, 0) + 1000 # integer between 1000 and 9999
    return(digi * 10^(expo - 3)) # the 3 reduces from 1000 to 1
  }
  zsize <-  sum(as.integer(z[5:8]) * c(1, 256, 65536, 16777216))
  alength <- (((zsize + 1) * 4) - 3) * 2
  ## 1 extra col at front, 4 rows excl DI, ID etc, 3 -Infs (DD start, DD MD end), 2 bytes per entry
  astart <- 9
  aend <- alength + 9 - 1
  A <- z[astart:aend]
  A <- apply(matrix(A, nrow = 2), 2, decode1) * -1
  A <- c(-Inf, A) ## append first DD transition
  lcis <- seq(length(A) - 1, length(A)) # last column indices
  lastcol <- c(-Inf, -Inf, A[lcis]) # final DD, MD, MM and IM transitions
  A <- A[-lcis]
  A <- c(A, lastcol)
  A <- matrix(A, nrow = 4) # just DD, MD, MM and IM at the moment
  DMrow <- log(1 - exp(A[1, ]))
  DMrow[1] <- -Inf
  DMrow[length(DMrow)] <- 0
  DIrow <- rep(-Inf, zsize + 1)
  MIrow <- (1 - exp(A[2, ])) - exp(A[3, ])
  MIrow[MIrow < 1e-06] <- 1e-06
  MIrow <- log(MIrow)
  IDrow <- rep(-Inf, zsize + 1)
  IIrow <- 1 - exp(A[4, ])
  IIrow[IIrow < 1e-06] <- 1e-06
  IIrow <- log(IIrow)
  A <- rbind(A[1, ], DMrow, DIrow, A[2:3, ], MIrow, IDrow, A[4, ], IIrow)
  dimnames(A) <- list(type = c("DD", "DM", "DI", "MD", "MM", "MI", "ID", "IM", "II"),
                      module = paste(0:zsize))
  estart <- aend + 1
  eend <- length(z) - 22 #(4 x 2 for qe, 7 x 2 for qa)
  E <- z[estart:eend]
  E <- apply(matrix(E, nrow = 2), 2, decode1) * -1
  E <- matrix(E, nrow = 3)
  Trow <- apply(exp(E), 2, function(v) 1 - v[1] - v[2] - v[3])
  Trow[Trow < 1e-06] <- 1e-06
  E <- rbind(E, log(Trow))
  dimnames(E) <- list(residue = c("A", "C", "G", "T"), position <- paste(1:zsize))
  qastart <- eend + 1
  qaend <- qastart + 13 #(7 * 2 - 1)
  tmp <- z[qastart:qaend]
  tmp <- apply(matrix(tmp, nrow = 2), 2, decode1) * -1
  qa <- structure(rep(-Inf, 9), names = c("DD", "DM", "DI", "MD", "MM", "MI", "ID", "IM", "II"))
  qa[c(1, 2, 4, 5, 6, 8, 9)] <- tmp
  qestart <- qaend + 1
  qeend <- length(z)
  qe <- z[qestart:qeend]
  qe <- apply(matrix(qe, nrow = 2), 2, decode1) * -1
  names(qe) <- c("A", "C", "G", "T")
  res <- list(size = zsize, A = A, E = E, qa = qa, qe = qe)
  class(res) <- "PHMM"
  return(res)
}
################################################################################
