---
title: "The 'insect' R package and bioinformatic pipeline."
subtitle: "Tutorial 1: reading and classifying NGS data."
author: "Shaun Wilkinson"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: kable.css
vignette: >
  %\VignetteIndexEntry{Introduction to the insect package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

------------------------------------------------------------------------

Introduction
------------

Welcome to the **insect** R package, a pipeline for classifying next
generation sequencing (NGS) amplicon libraries with **in**formatic
**se**quence **c**lassification **t**rees. The pipeline employs a
machine-learning approach that uses a set of *training* sequences
obtained from GenBank, BOLD and other sources to *learn* a
classification tree, which is then used to assign taxonomic IDs to a set
of *query* sequences (e.g. generated from an NGS platform such as
Illumina MiSeq). The package also includes a suite of functions for
FASTQ/FASTA sequence parsing, de-multiplexing, paired-end read
stitching, primer trimming, quality filtering, de-replication,
re-replication, etc. Most of the functions contained within the
**insect** package are generally better suited to run on multiple
processors; however, smaller datasets can be run on standard personal
computers if time is available. While not a prerequisite, **insect** is
designed to be used in conjunction with the **ape** package (Paradis *et
al.*, 2004; Paradis, 2012), which features a memory-efficient binary
format for DNA (the "DNAbin" object type), and the **dada2** package
(Callahan *et al.*, 2016) which contains essential functions for
de-noising high-throughput sequencing data and other important
processing steps.

The **insect** package can be used to analyze environmental DNA (eDNA)
meta-barcode libraries as well as single-source NGS/Sanger amplicon
sequences.

The most time-consuming and memory-intensive stage of the **insect**
work-flow generally involves training a DNA classifier. For example, the
COI classifier used in this tutorial, which was built from a training
dataset consisting of 150,000 unique ~310 bp COI barcode sequences, took
around three days to run on 24 CPUs and used around 40 GB of memory. The
**insect** classification trees are amplicon specific, so a unique tree
is generally required for each primer set. However, trees are already
available for some of the more commonly used barcoding primers
[here](https://www.dropbox.com/sh/0n4a1xsgzzj39el/AADNDDMP5QVj0PmbuEOflZJXa?dl=0).
The package also includes functions and instructions for downloading and
filtering training data (including a "virtual PCR" tool and a taxonomic
quality filter), building the taxonomy database, and training the
classifier; however, these methods are beyond the scope of this
introductory tutorial. New classification trees and updates are
frequently added to the collection, so please feel free to suggest a
barcoding primer set with which to train a classifier and we will
endeavor to add it to the list.

To produce a classification tree, the training data is first obtained
from GenBank, BOLD and/or other databases where barcode sequences with
accurate species-level IDs are available. These sequences are filtered
to remove any with obvious taxonomic labeling issues, and trimmed to
retain only the region of interest using the `virtualPCR` function
(sequences that do not span the entire amplicon region are removed). the
`learn` function then recursively partitions the training sequences as
follows: The dataset is initially divided in two, and a profile hidden
Markov model is derived for each subset (see Durbin et al. (1998) for a
detailed description of these models). The lowest common taxon of each
subset is also stored at each new node. The partitioning and model
training procedure then continues recursively, splitting the training
data into smaller and smaller subsets while adding new nodes, models and
taxonomic information to the classification tree.

Once the classifier tree has been trained, query sequences obtained from
the specified primer set can be analysed to assign taxonomic IDs along
with confidence values. The classification algorithm works as follows:
starting from the root node of the classification tree, the *likelihood*
of the query sequence (the full probability of the sequence given a
particular model) is computed for each of the models at the child nodes
using the forward algorithm (see Durbin et al. (1998)). The competing
likelihood values are then compared by computing their Akaike weights
(see Johnson and Omland, 2004). If one model is overwhelmingly more
likely to have produced the sequence than the other, that child node is
selected and the classification is updated to reflect the taxonomic
information of the training sequences belonging to the node.

This procedure is repeated recursively, continuing down the tree until
either an inconclusive result is returned from the model comparison test
(i.e. the Akaike weight is lower than a pre-defined threshold, usually
0.9), or a terminal leaf node is reached, at which point a species-level
ID is generally returned. The `classify` function outputs the taxon
name, rank and ID number (i.e. NCBI taxon ID, WORMS aphia ID, or other
identifier depending on the taxonomy database used in the training
step), along with the Akaike weight of the model at the final node. Note
that the default behavior is for the Akaike weight to 'decay' as it
moves down the tree, by computing the cumulative product of all
preceding Akaike weight values. This is perhaps an overly conservative
approach, but it minimizes the chance of mis-classifying or
over-classifying the query sequences.

In addition to the two key functions `learn` and `classify`, the package
includes several tools to encode the work-flow from raw sequence data
input to tabular output. At any stage during the process, users can
export the sequence data using the `writeFASTA` or `writeFASTQ`
functions.

A worked example
----------------

This tutorial demonstrates the **insect** work-flow using an example
dataset of COI sequences derived from Autonomous Reef Monitoring
Structures (ARMS) in Timor-Leste, amplified using the metazoan COI
barcoding primers mlCOIintF and jgHCO2198 (GGWACWGGWTGAACWGTWTAYCCYCC
and TAIACYTCIGGRTGICCRAARAAYCA, respectively; Leray et al. (2013)).

First install and load the package as follows:

    install.packages("insect")
    library(insect)

Next, download the latest marine eDNA classifier for the Leray et al.
(2013) primer set from
[here](https://www.dropbox.com/s/aawh33hneqru6j9/metazoan_COI_marine_v3.zip?dl=0)
and extract the contents of the zip archive to the current working
directory.

This can alternatively be done from within R as follows:

    URL <- "https://www.dropbox.com/s/aawh33hneqru6j9/metazoan_COI_marine_v3.zip?dl=1"
    download.file(URL, destfile = "metazoan_COI_marine_v3.zip", mode = "wb")
    unzip("metazoan_COI_marine_v3.zip")
    file.remove("metazoan_COI_marine_v3.zip")

The zip archive contains the following files:

-   `README.txt` a brief description of the files contained within the
    archive
-   `classification_tree.rds` data file containing the classifier
-   `training_data.rds` data file containing the training data used to
    train the classifier, as a "DNAbin" list object with WoRMS aphia ID
    numbers included in the sequence names
-   `COI_sample1_read1.fastq` and `COI_sample1_read2.fastq` example
    FASTQ files from an ARMS experiment containing 1000 COI amplicons
    sequenced in both directions
-   `COI_sample2.fastq` example FASTQ file from an ARMS experiment
    containing 1000 pre-stiched COI sequence reads

We generally recommend using the **dada2** package (Callahan *et al.*,
2016) to de-noise and stitch sequences prior to taxonomic classification
with **insect**; however, standard pre-processing functions are provided
with the insect package for convenience. Non-stitched and pre-stitched
example FASTQ files are included in the zip archive in order to
demonstrate the pre-processing work-flow for both of these
commonly-encountered input data formats.

The FASTQ files can be read into R as either concatenated upper-case
character strings or binary "DNAbin" objects, with "quality" attributes.
In this example we will opt for the latter by leaving `bin = TRUE` (the
default option). This is because subsetting or concatenating the
character vector will result in the loss of the "quality" attributes,
while this isn't an issue with the DNAbin list objects, whose quality
scores are attributed to each sequence individually.

    S1R1 <- readFASTQ("COI_sample1_read1.fastq")
    S1R2 <- readFASTQ("COI_sample1_read2.fastq")
    S2 <- readFASTQ("COI_sample2.fastq")

The next step is to stitch the forward and reverse reads from sample 1
together to create a single vector of sequences, similar to sample 2.
The `stitch` function performs this operation, as well as optionally
removing any sequences that don't contain the primer sequences in either
direction, trimming the primers from those that do, and outputting all
sequences in the 5' -&gt; 3' orientation. The optional primer
filter-trim and sequence orientation is activated by passing the primer
sequences to the `stitch` function (again either as character strings or
"DNAbin" objects).

    S1 <- stitch(S1R1, S1R2, up = "GGWACWGGWTGAACWGTWTAYCCYCC", 
                 down = "TAIACYTCIGGRTGICCRAARAAYCA")

Of the original 1000 sequences in sample 1, 299 were retained and
stitched while the remainder didn't contain both of the primer sequences
in either direction and were discarded.

The sample 2 sequences have been pre-stitched but still have their
primers attached. Here, we will use the `trim` function to discard any
sequences that don't contain both primer sequences, orientate all
sequences in the 5' -&gt; 3' direction, and finally, trim the primer
sequences from each end:

    S2 <- trim(S2, up = "GGWACWGGWTGAACWGTWTAYCCYCC", 
                 down = "TAIACYTCIGGRTGICCRAARAAYCA")

Next we merge all samples together into one DNAbin list, while retaining
the sample origins in the sequence names. In keeping with the style of
the **qiime** pipeline (Caporaso *et al.*, 2010), we append the sample
names to the front of each sequence name, delimited with an underscore:

    names(S1) <- paste0("Sample1_", names(S1))
    names(S2) <- paste0("Sample2_", names(S2))
    x <- c(S1, S2)

The sequences now need further filtering to remove low-quality reads,
those with ambiguous base calls, singletons and overly short/long
sequences. The function `qfilter` is a quality control function that can
be used to apply any or all of these filters. By default, the function
removes any sequences with a mean quality score less than 30, those that
contain at least one ambiguous base call, those that appear only once in
the dataset, and those with length outside the range of 50 - 500
nucleotides (inclusive). To disable any of the filters, simply set the
parameter value to `NULL`. In this example we will stick with the
default settings, except that we change the acceptable length range to
250 - 350 bp.

    x <- qfilter(x, minlength = 250, maxlength = 350)

If sequences were pre-processed with **dada2** instead of **insect**
(i.e. by following the work-flow
[here](https://benjjneb.github.io/dada2/tutorial.html)), the table of
chimera-removed amplicon sequence variants (ASVs) can be read in as
follows:

    x <- char2dna(colnames(seqtab.nochim))
    ## optionally remove column names that can flood the console 
    colnames(seqtab.nochim) <- NULL 

In this case we can simply transpose and append the `seqtab.nochim` ASV
abundance table to the table of taxonomic information produced by
`insect::classify`.

The final step is to load the classification tree and run the `classify`
function to assign taxonomic IDs and confidence scores. First, read in
the `classification_tree.rds` file:

    tree <- readRDS("classification_tree.rds")

This 'insect' class object is just a large dendrogram with additional
attributes for classifying sequences including profile HMMs and
taxonomic information. The `classify` function may take a minute or two
to process these sequences, since it uses a computationally intensive
dynamic programming algorithm to find the likelihood values of each
(unique) sequence given the models at each node of the tree. The
exception is when the argument `ping` is set to TRUE and there is an
exact match between the query sequence and at least one of the sequences
in the training dataset, in which case the function simply returns the
common ancestor of the matching sequences. The `classify` function can
also be run in parallel by setting the `cores` argument to 2 or more
depending on the number available (you can run `parallel::detectCores()`
if you are unsure). Classification times can vary, and depend on several
factors including the number of unique sequences in the dataset, the
size of the tree, the length of the input sequences, the processing
speed, number of processors used, etc. The average time for classifying
COI sequences using the tree above is approximately 3 - 4 seconds per
unique sequence per processor. For example, a dataset containing 10,000
sequences of which 1000 are unique would take around an hour on a single
processor, half an hour on two, etc.

    longDF <- classify(x, tree, cores = 4)

<!-- note newlines needed between html tags and code chunk -->
<table>
<thead>
<tr class="header">
<th align="left">representative</th>
<th align="right">taxID</th>
<th align="left">taxon</th>
<th align="left">rank</th>
<th align="right">score</th>
<th align="left">kingdom</th>
<th align="left">phylum</th>
<th align="left">class</th>
<th align="left">order</th>
<th align="left">family</th>
<th align="left">genus</th>
<th align="left">species</th>
<th align="right">Sample1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">4</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">30</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9922</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">16</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9561</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">23</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">27</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">24</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">1.0000</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">368670</td>
<td align="left">Florideophyceae</td>
<td align="left">class</td>
<td align="right">0.9599</td>
<td align="left">Plantae</td>
<td align="left">Rhodophyta</td>
<td align="left">Florideophyceae</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9537</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">Sample1_M...</td>
<td align="right">1041930</td>
<td align="left">Terpios gelatinosus</td>
<td align="left">species</td>
<td align="right">NA</td>
<td align="left">Animalia</td>
<td align="left">Porifera</td>
<td align="left">Demospongiae</td>
<td align="left">Suberitida</td>
<td align="left">Suberitidae</td>
<td align="left">Terpios</td>
<td align="left">Terpios gelatinosus</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">Sample1_M...</td>
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9984</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
</tr>
</tbody>
</table>

The function produces a data frame with one row for each unique
sequence, the first few rows of which are shown above. Assuming `ping`
is set to `TRUE`, query sequences that have exact matches in the
training dataset (and hence bypass the recursive classification
procedure; e.g. *Terpios gelatinosus* above), are assigned a score of
`NA`.

For **dada2** users, the ASV abundance table can be transposed and
appended to the table of taxonomic information at this point if
required:

    longDF <- cbind(longDF[-ncol(longDF)], t(seqtab.nochim))

For a more succinct output we can aggregate the table to show one row
for each unique taxon as follows:

    taxa <- aggregate(longDF[3:12], longDF["taxID"], head, 1)
    counts <- aggregate(longDF[13:ncol(longDF)], longDF["taxID"], sum)
    shortDF <- merge(taxa, counts, by = "taxID")

<!-- note newlines needed between html tags and code chunk -->
<table>
<thead>
<tr class="header">
<th align="right">taxID</th>
<th align="left">taxon</th>
<th align="left">rank</th>
<th align="right">score</th>
<th align="left">kingdom</th>
<th align="left">phylum</th>
<th align="left">class</th>
<th align="left">order</th>
<th align="left">family</th>
<th align="left">genus</th>
<th align="left">species</th>
<th align="right">Sample1</th>
<th align="right">Sample2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">Biota</td>
<td align="left"></td>
<td align="right">1.0000</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">0</td>
<td align="right">47</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">Animalia</td>
<td align="left">kingdom</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">55</td>
<td align="right">88</td>
</tr>
<tr class="odd">
<td align="right">1086</td>
<td align="left">Eumalacostraca</td>
<td align="left">subclass</td>
<td align="right">0.9815</td>
<td align="left">Animalia</td>
<td align="left">Arthropoda</td>
<td align="left">Malacostraca</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">1090</td>
<td align="left">Peracarida</td>
<td align="left">superorder</td>
<td align="right">0.9884</td>
<td align="left">Animalia</td>
<td align="left">Arthropoda</td>
<td align="left">Malacostraca</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">0</td>
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="right">1102</td>
<td align="left">Harpacticoida</td>
<td align="left">order</td>
<td align="right">1.0000</td>
<td align="left">Animalia</td>
<td align="left">Arthropoda</td>
<td align="left">Hexanauplia</td>
<td align="left">Harpacticoida</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">0</td>
<td align="right">19</td>
</tr>
<tr class="even">
<td align="right">1135</td>
<td align="left">Amphipoda</td>
<td align="left">order</td>
<td align="right">0.9484</td>
<td align="left">Animalia</td>
<td align="left">Arthropoda</td>
<td align="left">Malacostraca</td>
<td align="left">Amphipoda</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">0</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="right">1839</td>
<td align="left">Ascidiacea</td>
<td align="left">class</td>
<td align="right">0.9999</td>
<td align="left">Animalia</td>
<td align="left">Chordata</td>
<td align="left">Ascidiacea</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">85</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">368670</td>
<td align="left">Florideophyceae</td>
<td align="left">class</td>
<td align="right">0.9599</td>
<td align="left">Plantae</td>
<td align="left">Rhodophyta</td>
<td align="left">Florideophyceae</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">1041930</td>
<td align="left">Terpios gelatinosus</td>
<td align="left">species</td>
<td align="right">NA</td>
<td align="left">Animalia</td>
<td align="left">Porifera</td>
<td align="left">Demospongiae</td>
<td align="left">Suberitida</td>
<td align="left">Suberitidae</td>
<td align="left">Terpios</td>
<td align="left">Terpios gelatinosus</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
</tbody>
</table>

As shown in the above example, many of the sequences return fairly
uninformative taxon IDs (e.g. 'Biota'). This is a fairly typical feature
of eDNA datasets that can contain a large number of pseudo-genes,
chimeras, other PCR artifacts, and novel sequences that are dissimilar
to anything recorded in the reference database(s). Query sequences with
high similarity to reference sequences can also occasionaly produce
uninformative classifications due to inconclusive model comparison tests
at top-level nodes. This may be circumvented by reducing the `threshold`
parameter or setting `decay = FALSE`; however, users are advised against
the excessive relaxation of these parameters since it may increase the
chance of returning spurious classifications (these tend to be very rare
when using the conservative default values of `0.9` and `TRUE`,
respectively). Further testing and optimization may help to address some
of these best-practice considerations, and will be a focus of future
research.

This basic introduction to the **insect** package has outlined the steps
involved in parsing paired-end NGS data, and filtering, trimming
primers, de-replication, and taxonomic identification using a pre-built
classification tree. The next tutorial will deal with downloading and
curating a primer-specific local sequence database and using it to build
a classification tree.

Please feel free to email the author directly with any feedback or
questions at shaunpwilkinson AT gmail DOT com. Bug reports can also be
directed to the [GitHub issues
page](http://github.com/shaunpwilkinson/insect/issues).

Acknowledgements
----------------

This software was developed with funding from a Rutherford Foundation
Postdoctoral Research Fellowship from the Royal Society of New Zealand.
Thanks to Molly Timmers for helpful feedback and sharing COI data, and
to Danyl McLauchlan and Dinindu Senanayake for assistance with high
performance computing facilities.

References
----------

Callahan,B.J. *et al.* (2016) DADA2: High-resolution sample inference
from illumina amplicon data. *Nature Methods*, **13**, 581–583.

Caporaso,J.G. *et al.* (2010) QIIME allows analysis of high-throughput
community sequencing data. *Nature Methods*, **7**, 335–336.

Durbin,R. *et al.* (1998) Biological Sequence Analysis: Probabilistic
Models of Proteins and Nucleic Acids. Cambridge University Press,
Cambridge.

Johnson,J.B. and Omland,K.S. (2004) Model selection in ecology and
evolution. *Trends in Ecology and Evolution*, **19**, 101–108.

Leray,M. *et al.* (2013) A new versatile primer set targeting a short
fragment of the mitochondrial COI region for metabarcoding metazoan
diversity: application for characterizing coral reef fish gut contents.
*Frontiers in Zoology*, **10**, 34.

Paradis,E. (2012) Analysis of Phylogenetics and Evolution with R. Second
Edition. Springer, New York.

Paradis,E. *et al.* (2004) APE: analyses of phylogenetics and evolution
in R language. *Bioinformatics*, **20**, 289–290.
